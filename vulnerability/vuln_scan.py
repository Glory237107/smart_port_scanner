import nmap
import requests
from config import settings

def scan_vulnerabilities(target_ip, open_ports, threat_manager=None):
    """
    Scan vulnerabilities with integrated threat assessment
    
    Args:
        target_ip: Target IP address
        open_ports: List of open ports to scan
        threat_manager: ThreatManager instance for threat assessment (optional)
    
    Returns:
        Dictionary of vulnerability results
    """
    scanner = nmap.PortScanner()
    vuln_results = {}

    print(f" Scanning vulnerabilities on {len(open_ports)} open ports...")

    for port in open_ports:
        try:
            print(f" Analyzing port {port}...")
            
            # Scan the port for service info and vulnerabilities
            scanner.scan(target_ip, str(port), arguments='-sV --script vuln')
            port_data = scanner[target_ip]['tcp'].get(port, {})

            product = port_data.get('product', '').strip()
            version = port_data.get('version', '').strip()
            name = port_data.get('name', '').strip()

            if product and version:
                service_version = f"{product} {version}"
            elif product:
                service_version = product
            else:
                service_version = name or "Unknown"

            # Query vulnerabilities from Vulners
            vulnerabilities = query_vulners(product, version)

            vuln_results[port] = {
                'service': service_version,
                'vulnerabilities': vulnerabilities
            }

            # NEW: Enhanced threat assessment based on vulnerabilities
            if threat_manager:
                assess_vulnerability_threats(
                    threat_manager, target_ip, port, service_version, vulnerabilities
                )

        except Exception as e:
            vuln_results[port] = {
                'service': 'Unknown',
                'vulnerabilities': [],
                'error': str(e)
            }
            
            # Log scanning errors as potential evasion attempts
            if threat_manager:
                additional_info = {
                    'scan_error': str(e),
                    'suspicious': True,
                    'reason': 'scan_evasion_detected'
                }
                threat_manager.process_scan_result(
                    ip=target_ip,
                    port=port,
                    service="scan_error",
                    is_open=True,
                    additional_info=additional_info
                )

    return vuln_results

def assess_vulnerability_threats(threat_manager, target_ip, port, service, vulnerabilities):
    """Assess threats based on discovered vulnerabilities"""
    
    # Count actual CVE vulnerabilities (not error messages)
    real_vulns = [v for v in vulnerabilities if v.startswith(('CVE-', 'VULNERS:'))]
    
    if real_vulns:
        # High threat: Multiple CVEs found
        if len(real_vulns) >= 3:
            additional_info = {
                'vulnerability_count': len(real_vulns),
                'critical_vulns': real_vulns[:3],  # First 3 for logging
                'threat_level': 'critical',
                'suspicious': True,
                'auto_block_reason': f'Multiple vulnerabilities ({len(real_vulns)} CVEs found)'
            }
            
            print(f" CRITICAL: {target_ip}:{port} has {len(real_vulns)} known vulnerabilities!")
            
            # Force high severity for multiple vulnerabilities
            threat_manager.log_threat(target_ip, port, service, "high", additional_info)
            threat_manager.block_ip(target_ip, f"Critical vulnerability exposure: {len(real_vulns)} CVEs on {service}")
            
        # Medium threat: 1-2 CVEs found  
        else:
            additional_info = {
                'vulnerability_count': len(real_vulns),
                'vulnerabilities': real_vulns,
                'threat_level': 'elevated',
                'suspicious': True
            }
            
            print(f"  WARNING: {target_ip}:{port} has {len(real_vulns)} known vulnerability(s)")
            threat_manager.log_threat(target_ip, port, service, "medium", additional_info)
    
    # Check for potentially dangerous services even without CVEs
    elif is_dangerous_service(service, port):
        additional_info = {
            'service_risk': 'high',
            'reason': 'inherently_dangerous_service',
            'suspicious': True
        }
        
        print(f" RISK: {target_ip}:{port} running potentially dangerous service: {service}")
        threat_manager.log_threat(target_ip, port, service, "medium", additional_info)

def is_dangerous_service(service, port):
    """Check if service is inherently dangerous"""
    dangerous_patterns = [
        'telnet', 'ftp', 'rlogin', 'rsh', 'finger',
        'unprotected', 'anonymous', 'default',
        'backdoor', 'trojan'
    ]
    
    dangerous_ports = [21, 23, 512, 513, 514, 79]  # Known risky protocols
    
    service_lower = service.lower()
    
    return (any(pattern in service_lower for pattern in dangerous_patterns) or 
            port in dangerous_ports)

def query_vulners(product, version):
    """Query Vulners API for vulnerabilities (unchanged from original)"""
    if not product or not version:
        return ["Insufficient data to query vulnerabilities."]

    try:
        url = 'https://vulners.com/api/v3/search/lucene/'
        headers = {'Content-Type': 'application/json'}
        payload = {
            'query': f"{product} {version}",
            'apiKey': settings.vulners_api_key
        }

        response = requests.post(url, json=payload, headers=headers)
        if response.status_code == 200:
            data = response.json()
            vulnerabilities = []
            for item in data.get('data', {}).get('search', []):
                vuln_id = item.get('id', '').strip()
                title = item.get('title', '').strip()

                #  Only include valid CVE/title results
                if vuln_id and title:
                    vulnerabilities.append(f"{vuln_id}: {title}")

            return vulnerabilities if vulnerabilities else ["No known vulnerabilities found."]
        else:
            return [f"Vulners API returned status code {response.status_code}"]

    except Exception as e:
        return [f"Error querying Vulners: {e}"]

def format_report_table_html(scan_results):
    """Format HTML report (unchanged from original)"""
    headers = []
    versions = []
    ports = []
    statuses = []
    details = []

    for port, result in scan_results.items():
        service = result.get('service', 'Unknown')
        version = service.split()[-1] if ' ' in service else 'Unknown'
        name = service.split()[0] if ' ' in service else service

        headers.append(name)
        versions.append(version)
        ports.append(str(port))

        vulns = result.get('vulnerabilities', [])
        if not vulns:
            statuses.append('<span style="color:#28a745;"><b>No vulnerabilities</b></span>')  # ğŸ’š Green
            details.append("<span style='color:#2196F3;'>No issues found</span>")  # ğŸ’™ Blue
        elif "Insufficient data" in vulns[0]:
            statuses.append('<span style="color:#2196F3;"><b>Insufficient data</b></span>')  # ğŸ’™ Blue
            details.append("<span style='color:#2196F3;'>Couldn't query CVEs</span>")  # ğŸ’™ Blue
        elif "Error" in vulns[0]:
            statuses.append('<span style="color:#f44336;"><b>Error</b></span>')  # â¤ï¸ Red
            details.append(f"<span style='color:#2196F3;'>{vulns[0]}</span>")  # ğŸ’™ Blue
        else:
            statuses.append(f'<span style="color:#f44336;"><b>{len(vulns)} found</b></span>')  # â¤ï¸ Red
            details_text = '<br>'.join(vulns[:5]) + ("<br>..." if len(vulns) > 5 else "")
            details.append(f"<span style='color:#2196F3;'>{details_text}</span>")  # ğŸ’™ Blue

    html = f"""
    <html>
    <body style="background-color: #f5f5f5; font-family: Arial, sans-serif;">
    <h2 style="color:#007ACC;">Smart Scan Report for Host</h2>
    <table border="1" cellpadding="10" cellspacing="0" style="border-collapse: collapse; border: 2px solid black; width: 100%; font-size: 14px; text-align: center;">
        <tr style="background-color: #007ACC; color: white;">
            <th>Service</th>{''.join(f"<th>{h}</th>" for h in headers)}
        </tr>
        <tr style="background-color: #E3F2FD;">
            <td><b>Version</b></td>{''.join(f"<td style='color:#000000;'>{v}</td>" for v in versions)}  <!-- ğŸ–¤ Black -->
        </tr>
        <tr style="background-color: #FAFAFA;">
            <td><b>Port</b></td>{''.join(f"<td style='color:#444;'>{p}</td>" for p in ports)}
        </tr>
        <tr style="background-color: #E3F2FD;">
            <td><b>Status</b></td>{''.join(f"<td>{s}</td>" for s in statuses)}
        </tr>
        <tr style="background-color: #FAFAFA;">
            <td><b>Details</b></td>{''.join(f"<td>{d}</td>" for d in details)}  <!-- ğŸ’™ Blue -->
        </tr>
    </table>
    </body>
    </html>
    """
    return html